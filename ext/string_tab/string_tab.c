/* generated by Ruby2CExtension 0.2.0 (ruby 1.8.7 (2011-06-30) [x86_64-linux]) on Fri Mar 16 22:36:38 -0400 2012 */
#include <ruby.h>
#include <node.h>
#include <env.h>
#include <st.h>
extern VALUE ruby_top_self;
static VALUE org_ruby_top_self;
static ID sym[14];
static void init_syms() {
sym[0] = rb_intern("String");
sym[1] = rb_intern(">=");
sym[2] = rb_intern("*");
sym[3] = rb_intern("gsub");
sym[4] = rb_intern("Regexp");
sym[5] = rb_intern("escape");
sym[6] = rb_intern("-@");
sym[7] = rb_intern("tab");
sym[8] = rb_intern("replace");
sym[9] = rb_intern("=~");
sym[10] = rb_intern("length");
sym[11] = rb_intern("-");
sym[12] = rb_intern("indent");
sym[13] = rb_intern("tabto");
}
static VALUE global[8];
static void init_globals() {
global[0] = rb_str_new(" ", 1);
rb_global_variable(&(global[0]));
global[1] = rb_reg_new("^", 1, 0);
rb_global_variable(&(global[1]));
global[2] = rb_str_new("^", 1);
rb_global_variable(&(global[2]));
global[3] = Qfalse;
rb_global_variable(&(global[3]));
global[4] = rb_str_new("{0,", 3);
rb_global_variable(&(global[4]));
global[5] = rb_str_new("}", 1);
rb_global_variable(&(global[5]));
global[6] = rb_str_new("", 0);
rb_global_variable(&(global[6]));
global[7] = rb_reg_new("^( *)\\S", 7, 0);
rb_global_variable(&(global[7]));
}
static void def_only_once(ID mid) {
rb_raise(rb_eTypeError, "def for \"%s\" can only be used once", rb_id2name(mid));
}
static void wrong_arg_num(int argc, int exp) {
rb_raise(rb_eArgError, "wrong number of arguments (%d for %d)", argc, exp);
}
static VALUE class_prep(VALUE prefix, VALUE super, ID cname) {
VALUE klass;
if (rb_const_defined_at(prefix, cname)) {
klass = rb_const_get_at(prefix, cname);
if (TYPE(klass) != T_CLASS) rb_raise(rb_eTypeError, "%s is not a class", rb_id2name(cname));
if (super) {
VALUE tmp = rb_class_real(RCLASS(klass)->super);
if (tmp != super) rb_raise(rb_eTypeError, "superclass mismatch for class %s", rb_id2name(cname));
}
if (ruby_safe_level >= 4) rb_raise(rb_eSecurityError, "extending class prohibited");
}
else {
if (!super) super = rb_cObject;
klass = rb_define_class_id(cname, super);
rb_set_class_path(klass, prefix, rb_id2name(cname));
rb_const_set(prefix, cname, klass);
rb_class_inherited(super, klass);
}
return klass;
}
static VALUE const_get(ID id, NODE *cref) {
NODE *cbase = cref;
VALUE result;
while (cbase && cbase->nd_next) {
VALUE klass = cbase->nd_clss;
while (RCLASS(klass)->iv_tbl && st_lookup(RCLASS(klass)->iv_tbl, id, &result)) {
if (result == Qundef) {
if (!RTEST(rb_autoload_load(klass, id))) break;
continue;
}
return result;
}
cbase = cbase->nd_next;
}
return rb_const_get(cref->nd_clss, id);
}
static void class_nil_check(VALUE klass) {
if (NIL_P(klass)) rb_raise(rb_eTypeError, "no class/module to add method");
}
static VALUE method_1(int meth_argc, VALUE *meth_argv, VALUE self) {
VALUE res;
VALUE lvar[2];
rb_mem_clear(lvar, 2);
if (meth_argc < 1) wrong_arg_num(meth_argc, 1);
if (meth_argc > 2) wrong_arg_num(meth_argc, 2);
lvar[0] = meth_argv[0];
if (meth_argc > 1) {
lvar[1] = meth_argv[1];
}
else {
/* lasgn */
/* str */
(lvar[1] = rb_str_new3(global[0]));
}
/* block */
/* if */
/* call */
/* lvar */
{
VALUE recv = lvar[0];
const int argc = 1;
VALUE argv[1];
/* lit */
argv[0] = LONG2FIX(0);
res = rb_funcall3(recv, sym[1] /* >= */, argc, argv);
}
if (RTEST(res)) {
/* fcall */
{
VALUE recv = self;
const int argc = 2;
VALUE argv[2];
/* lit */
argv[0] = global[1];
/* call */
/* lvar */
{
VALUE recv = lvar[1];
const int argc = 1;
VALUE argv[1];
/* lvar */
argv[0] = lvar[0];
res = rb_funcall3(recv, sym[2] /* * */, argc, argv);
}
argv[1] = res;
res = rb_funcall2(recv, sym[3] /* gsub */, argc, argv);
}
}
else {
/* fcall */
{
VALUE recv = self;
const int argc = 2;
VALUE argv[2];
/* dregx */
{
VALUE str, str2;
str = rb_str_new3(global[2]);
/* evstr */
/* call */
/* const */
{
VALUE recv = const_get(sym[4] /* Regexp */, (RNODE(global[3])));
const int argc = 1;
VALUE argv[1];
/* lvar */
argv[0] = lvar[1];
res = rb_funcall3(recv, sym[5] /* escape */, argc, argv);
}
str2 = rb_obj_as_string(res);
rb_str_append(str, str2);
OBJ_INFECT(str, str2);
/* str */
str2 = rb_str_new3(global[4]);
rb_str_append(str, str2);
OBJ_INFECT(str, str2);
/* evstr */
/* call */
/* lvar */
str2 = rb_obj_as_string(rb_funcall3(lvar[0], sym[6] /* -@ */, 0, 0));
rb_str_append(str, str2);
OBJ_INFECT(str, str2);
/* str */
str2 = rb_str_new3(global[5]);
rb_str_append(str, str2);
OBJ_INFECT(str, str2);
res = str;
}
argv[0] = rb_reg_new(RSTRING(res)->ptr, RSTRING(res)->len, 0);
/* str */
argv[1] = rb_str_new3(global[6]);
res = rb_funcall2(recv, sym[3] /* gsub */, argc, argv);
}
}
return res;
}
static VALUE method_2(int meth_argc, VALUE *meth_argv, VALUE self) {
VALUE res;
VALUE lvar[2];
rb_mem_clear(lvar, 2);
if (meth_argc < 1) wrong_arg_num(meth_argc, 1);
if (meth_argc > 2) wrong_arg_num(meth_argc, 2);
lvar[0] = meth_argv[0];
if (meth_argc > 1) {
lvar[1] = meth_argv[1];
}
else {
/* lasgn */
/* str */
(lvar[1] = rb_str_new3(global[0]));
}
/* block */
/* fcall */
{
VALUE recv = self;
const int argc = 1;
VALUE argv[1];
/* fcall */
{
VALUE recv = self;
const int argc = 2;
VALUE argv[2];
/* lvar */
argv[0] = lvar[0];
/* lvar */
argv[1] = lvar[1];
res = rb_funcall2(recv, sym[7] /* tab */, argc, argv);
}
argv[0] = res;
res = rb_funcall2(recv, sym[8] /* replace */, argc, argv);
}
return res;
}
static VALUE method_3(int meth_argc, VALUE *meth_argv, VALUE self) {
VALUE res;
VALUE lvar[1];
rb_mem_clear(lvar, 1);
if (meth_argc != 1) wrong_arg_num(meth_argc, 1);
lvar[0] = meth_argv[0];
/* block */
/* if */
/* match3 */
{
VALUE recv, val;
/* lit */
recv = global[7];
/* self */
val = self;
res = (TYPE(val) == T_STRING ? rb_reg_match(recv, val) : rb_funcall(val, sym[9] /* =~ */, 1, recv));
}
if (RTEST(res)) {
/* fcall */
{
VALUE recv = self;
const int argc = 1;
VALUE argv[1];
/* call */
/* lvar */
{
VALUE recv = lvar[0];
const int argc = 1;
VALUE argv[1];
/* call */
/* nth_ref */
argv[0] = rb_funcall3(rb_reg_nth_match(1, rb_backref_get()), sym[10] /* length */, 0, 0);
res = rb_funcall3(recv, sym[11] /* - */, argc, argv);
}
argv[0] = res;
res = rb_funcall2(recv, sym[12] /* indent */, argc, argv);
}
}
else {
/* self */
res = self;
}
return res;
}
static VALUE method_4(int meth_argc, VALUE *meth_argv, VALUE self) {
VALUE res;
VALUE lvar[1];
rb_mem_clear(lvar, 1);
if (meth_argc != 1) wrong_arg_num(meth_argc, 1);
lvar[0] = meth_argv[0];
/* block */
/* fcall */
{
VALUE recv = self;
const int argc = 1;
VALUE argv[1];
/* fcall */
{
VALUE recv = self;
const int argc = 1;
VALUE argv[1];
/* lvar */
argv[0] = lvar[0];
res = rb_funcall2(recv, sym[13] /* tabto */, argc, argv);
}
argv[0] = res;
res = rb_funcall2(recv, sym[8] /* replace */, argc, argv);
}
return res;
}
static VALUE class_module_scope_1(NODE *cref) {
VALUE s_class = (cref)->nd_clss;
/* block */
/* defn */
class_nil_check(s_class);
if (global[3]) def_only_once(sym[7] /* tab */);
global[3] = (VALUE)(cref);
rb_define_method(s_class, "tab", method_1, -1);
/* defn */
class_nil_check(s_class);
rb_define_method(s_class, "tab!", method_2, -1);
/* defn */
class_nil_check(s_class);
rb_define_method(s_class, "tabto", method_3, -1);
/* defn */
class_nil_check(s_class);
rb_define_method(s_class, "tabto!", method_4, -1);
return Qnil;
}
static void toplevel_scope_1(VALUE self, NODE *cref) {
VALUE res;
/* block */
/* class */
{
VALUE prefix, tmp_class;
prefix = (cref->nd_clss);
tmp_class = class_prep(prefix, 0, sym[0] /* String */);
res = class_module_scope_1(NEW_NODE(NODE_CREF, tmp_class, 0, cref));
}
}
void Init_tab() {
org_ruby_top_self = ruby_top_self;
rb_global_variable(&org_ruby_top_self);
init_syms();
init_globals();
NODE *cref = rb_node_newnode(NODE_CREF, rb_cObject, 0, 0);
toplevel_scope_1(ruby_top_self, cref);
}
